<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>sgope</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style id="graph-styles">
            body {
                margin: 0;
                padding: 20px;
                font-family: Arial, sans-serif;
                background: #1a1a1a;
                color: #fff;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                height: 100vh;
                box-sizing: border-box;
            }
            #graph {
                border: 1px solid #444;
                background: #222;
                width: 100%;
                flex-grow: 1;
            }
            .controls {
                margin-bottom: 20px;
                padding: 15px;
                background: #2a2a2a;
                border-radius: 5px;
                display: flex;
                align-items: center;
                flex-wrap: wrap;
                gap: 15px;
            }
            .node {
                cursor: pointer;
                stroke: #fff7;
                stroke-width: 1.5px;
                transition: opacity 0.2s;
                vector-effect: non-scaling-stroke;
            }
            .node.selected {
                stroke: #fff;
                stroke-width: 2px;
                filter: drop-shadow(0 0 4px #fff);
            }
            .link {
                stroke: #fff;
                stroke-opacity: 0.5;
                fill: none;
                pointer-events: none;
                vector-effect: non-scaling-stroke;
            }
            .link.cross-package {
                stroke-dasharray: 4, 4;
            }
            .highlight {
                stroke-opacity: 0.8;
            }
            .muted {
                stroke-opacity: 0.2;
            }
            .highlight.out {
                stroke: #4ecdc4 !important;
                stroke-width: 2px !important;
            }
            .highlight.in {
                stroke: #ff6b6b !important;
                stroke-width: 2px !important;
            }
            .highlight.internal {
                stroke: #ffffff !important;
                stroke-width: 2px !important;
            }
            .node-label {
                font-size: 10px;
                pointer-events: none;
                fill: #fff;
                text-shadow: #000 1px 0 10px;
            }
            .legend {
                position: fixed;
                right: 20px;
                top: 160px;
                background: #2a2a2a;
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #444;
            }
            .legend-item {
                margin: 5px 0;
                display: flex;
                align-items: center;
                font-size: 12px;
                cursor: pointer;
                transition: opacity 0.2s;
            }
            .legend-item.inactive {
                opacity: 0.3;
            }
            .legend-color {
                width: 12px;
                height: 12px;
                margin-right: 10px;
                border-radius: 50%;
            }
            .info {
                position: fixed;
                left: 20px;
                top: 160px;
                background: #2a2a2a;
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #444;
                width: 280px;
                max-height: 70vh;
                display: flex;
                flex-direction: column;
            }
            .sidebar-scroll {
                flex-grow: 1;
                overflow-y: auto;
                padding-right: 5px;
            }
            .sidebar-list {
                list-style: none;
                padding: 0;
                margin: 10px 0;
            }
            .sidebar-list li {
                padding: 4px 8px;
                margin: 2px 0;
                background: #333;
                border-radius: 3px;
                font-size: 11px;
                cursor: pointer;
                border-left: 3px solid transparent;
            }
            .sidebar-list li:hover {
                background: #444;
            }
            .li-outgoing {
                border-left-color: #4ecdc4 !important;
            }
            .li-incoming {
                border-left-color: #ff6b6b !important;
            }
            .li-search {
                border-left-color: #fff !important;
            }
            .li-selected {
                border-left-color: #ffd700 !important;
                background: #3d3d29 !important;
            }
            button {
                background: #444;
                color: white;
                border: 1px solid #666;
                padding: 5px 10px;
                cursor: pointer;
                border-radius: 3px;
            }
            button:hover {
                background: #555;
            }
            #search-box {
                width: 100%;
                padding: 8px;
                background: #333;
                border: 1px solid #555;
                color: #fff;
                border-radius: 3px;
                margin-bottom: 10px;
                box-sizing: border-box;
            }
            #search-results {
                max-height: 240px;
                overflow-y: auto;
                border-bottom: 1px solid #444;
                margin-bottom: 10px;
                flex-shrink: 0;
            }
            #node-info {
                flex-shrink: 3;
            }
            .section-header {
                font-size: 12px;
                color: #aaa;
                text-transform: uppercase;
                margin-top: 15px;
                display: block;
                border-bottom: 1px solid #444;
            }
            .pkg-badge {
                font-size: 9px;
                background: #444;
                padding: 2px 4px;
                border-radius: 2px;
                margin-left: 4px;
                color: #aaa;
            }
        </style>
    </head>
    <body>
        <div class="controls">
            <h3 style="margin: 0">sgope</h3>
            <label
                ><input type="checkbox" id="show-labels" checked />
                Labels</label
            >
            <label
                >Dist:
                <input
                    type="range"
                    id="link-distance"
                    min="30"
                    max="400"
                    value="320"
            /></label>
            <label
                >Charge:
                <input
                    type="range"
                    id="charge"
                    min="-1200"
                    max="-50"
                    value="-1050"
            /></label>
            <label
                >Cluster:
                <input
                    type="range"
                    id="cluster-strength"
                    min="0.1"
                    max="1"
                    step="0.05"
                    value="0.2"
            /></label>
            <button id="fit-selection">Fit Selection</button>
            <button id="reset-focus">Reset Focus</button
            ><button id="export-svg">Export SVG</button>
        </div>

        <div class="info">
            <input type="text" id="search-box" placeholder="Search nodes..." />
            <div id="search-results"></div>
            <div id="node-info" class="sidebar-scroll"></div>
        </div>

        <div class="legend">
            <div><strong>Node Types</strong></div>
            <div class="legend-item" data-group="func">
                <div class="legend-color"></div>
                <div>Function</div>
            </div>
            <div class="legend-item" data-group="type">
                <div class="legend-color"></div>
                <div>Type</div>
            </div>
            <div class="legend-item" data-group="const">
                <div class="legend-color"></div>
                <div>Const</div>
            </div>
            <div class="legend-item" data-group="var">
                <div class="legend-color"></div>
                <div>Var</div>
            </div>
        </div>

        <svg id="graph"></svg>

        <script>
            const data = DATA_PLACEHOLDER;

            // Color scheme
            const color = d3.scaleOrdinal(d3.schemeSet3);

            Array.from(document.getElementsByClassName("legend-item")).forEach(
                (n) => {
                    const colorKey = n.getAttribute("data-group");
                    Array.from(
                        n.getElementsByClassName("legend-color"),
                    ).forEach((c) => {
                        c.style = `background: ${color(colorKey)}`;
                    });
                },
            );

            // Performance optimizations: pre-compute maps and indices
            class GraphData {
                constructor(rawData) {
                    this.nodes = rawData.nodes;
                    this.links = rawData.links;

                    // Build fast lookup maps
                    this.nodeById = new Map(this.nodes.map((n) => [n.id, n]));

                    // Index links by source and target for O(1) lookups
                    this.linksBySource = new Map();
                    this.linksByTarget = new Map();

                    this.links.forEach((link) => {
                        if (!this.linksBySource.has(link.from)) {
                            this.linksBySource.set(link.from, []);
                        }
                        if (!this.linksByTarget.has(link.to)) {
                            this.linksByTarget.set(link.to, []);
                        }
                        this.linksBySource.get(link.from).push(link);
                        this.linksByTarget.get(link.to).push(link);
                    });

                    // Build package groups
                    this.packageGroups = new Map();
                    this.nodes.forEach((node) => {
                        if (!this.packageGroups.has(node.pkg)) {
                            this.packageGroups.set(node.pkg, []);
                        }
                        this.packageGroups.get(node.pkg).push(node);
                    });
                }

                getNode(id) {
                    return this.nodeById.get(id);
                }

                getOutgoingLinks(id) {
                    return this.linksBySource.get(id) || [];
                }

                getIncomingLinks(id) {
                    return this.linksByTarget.get(id) || [];
                }
            }

            // State management
            const state = {
                selectedNodeIds: new Set(),
                activeGroups: new Set(["func", "type", "const", "var"]),
                showLabels: true,
                linkDistance: 200,
                charge: -300,
                clusterStrength: 0.3,
            };

            let graphData, simulation, svg, g, link, node, label, zoom;
            let width, height;
            let renderScheduled = false;

            // Debounced render for performance
            function scheduleRender(callback) {
                if (!renderScheduled) {
                    renderScheduled = true;
                    requestAnimationFrame(() => {
                        callback();
                        renderScheduled = false;
                    });
                }
            }

            // Initialize visualization
            async function init() {
                graphData = new GraphData(data);

                setupSVG();
                setupSimulation();
                loadFromURL();
                updateGraph();
                setupEventListeners();
            }

            function setupSVG() {
                svg = d3.select("#graph");
                const bounds = svg.node().getBoundingClientRect();
                width = bounds.width;
                height = bounds.height;

                const styleSheet =
                    document.getElementById("graph-styles").sheet;

                zoom = d3
                    .zoom()
                    .scaleExtent([0.01, 4])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);

                        const baseOpacity = Math.min(
                            1,
                            Math.max(0.2, event.transform.k),
                        );

                        for (let i = 0; i < styleSheet.cssRules.length; i++) {
                            const rule = styleSheet.cssRules[i];
                            if (rule.selectorText === ".link") {
                                rule.style.opacity = baseOpacity;
                            }
                            if (rule.selectorText === ".node") {
                                rule.style.opacity = baseOpacity;
                            }
                        }
                    });

                svg.call(zoom);
                svg.on("click", () => {
                    resetFocus();
                });

                g = svg.append("g");
                // Use separate groups for links and nodes for better rendering
                g.append("g").attr("class", "links-group");
                g.append("g").attr("class", "nodes-group");
                g.append("g").attr("class", "labels-group");
            }

            function setupSimulation() {
                simulation = d3
                    .forceSimulation()
                    .force(
                        "link",
                        d3
                            .forceLink()
                            .id((d) => d.id)
                            .distance(state.linkDistance),
                    )
                    .force("charge", d3.forceManyBody().strength(state.charge))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("x", d3.forceX(width / 2).strength(0.01))
                    .force("y", d3.forceY(height / 2).strength(0.01))
                    .force(
                        "collision",
                        d3.forceCollide().radius(20).strength(1.0),
                    )
                    .alphaDecay(0.00688395157)
                    .on("tick", onTick)
                    .on("end", () => console.log("Simulation ended"));

                // Add error handler
                window.addEventListener("error", (e) => {
                    console.error(
                        "Error:",
                        e.message,
                        e.filename,
                        e.lineno,
                        e.colno,
                    );
                });
            }

            // Optimized tick handler - only update positions, not DOM structure
            function onTick() {
                scheduleRender(() => {
                    if (link) {
                        link.attr("x1", (d) => d.source.x || 0)
                            .attr("y1", (d) => d.source.y || 0)
                            .attr("x2", (d) => d.target.x || 0)
                            .attr("y2", (d) => d.target.y || 0);
                    }

                    if (node) {
                        node.attr("cx", (d) => d.x || 0).attr(
                            "cy",
                            (d) => d.y || 0,
                        );
                    }

                    if (label && state.showLabels) {
                        label
                            .attr("x", (d) => (d.x || 0) + 8)
                            .attr("y", (d) => (d.y || 0) + 3);
                    }
                });
            }

            function updateGraph() {
                // Filter nodes and links based on active groups
                const filteredNodes = graphData.nodes.filter((n) =>
                    state.activeGroups.has(n.kind),
                );
                const filteredNodeIds = new Set(filteredNodes.map((n) => n.id));
                const filteredLinks = graphData.links.filter(
                    (l) =>
                        filteredNodeIds.has(l.from) &&
                        filteredNodeIds.has(l.to),
                );

                // Apply package clustering force
                if (state.clusterStrength > 0) {
                    const packageCenters = computePackageCenters(filteredNodes);

                    // Custom clustering force that attracts nodes to package centers
                    // and repels nodes from other packages
                    const clusterForce = () => {
                        const strength = state.clusterStrength;
                        const alpha = simulation.alpha();

                        filteredNodes.forEach((node) => {
                            if (!node.pkg) return;

                            const center = packageCenters.get(node.pkg);
                            if (!center) return;

                            // Attract to own package center
                            const dx = center.x - node.x;
                            const dy = center.y - node.y;
                            node.vx += dx * strength * alpha * 0.1;
                            node.vy += dy * strength * alpha * 0.1;

                            // Repel from other package centers
                            packageCenters.forEach((otherCenter, otherPkg) => {
                                if (otherPkg === node.pkg) return;

                                const dx = node.x - otherCenter.x;
                                const dy = node.y - otherCenter.y;
                                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                                const repelStrength =
                                    (strength * 800) / (dist * dist);

                                node.vx += (dx / dist) * repelStrength * alpha;
                                node.vy += (dy / dist) * repelStrength * alpha;
                            });
                        });
                    };

                    simulation.force("cluster", clusterForce);
                } else {
                    // Remove clustering force if strength is 0
                    simulation.force("cluster", null);
                }

                renderGraph(filteredNodes, filteredLinks);
                updateSidebar();
            }

            function computePackageCenters(nodes) {
                const packages = Array.from(graphData.packageGroups.keys());
                const centers = new Map();
                const angleStep = (2 * Math.PI) / packages.length;
                const radius = Math.min(width, height) * 3.5; // Increased radius

                packages.forEach((pkg, i) => {
                    const angle = i * angleStep;
                    centers.set(pkg, {
                        x: width / 2 + radius * Math.cos(angle),
                        y: height / 2 + radius * Math.sin(angle),
                    });
                });

                return centers;
            }

            function renderGraph(nodes, links) {
                // Initialize node positions if not set
                nodes.forEach((node) => {
                    if (node.x === undefined) {
                        node.x = width / 2 + (Math.random() - 0.5) * 100;
                    }
                    if (node.y === undefined) {
                        node.y = height / 2 + (Math.random() - 0.5) * 100;
                    }
                });

                // Convert links to D3 format (source, target instead of from, to)
                const d3Links = links.map((l) => ({
                    source: l.from,
                    target: l.to,
                    from: l.from,
                    to: l.to,
                }));

                // Update links
                const linkGroup = g.select(".links-group");
                link = linkGroup
                    .selectAll("line")
                    .data(d3Links, (d) => `${d.from}-${d.to}`);

                link.exit().remove();

                const linkEnter = link
                    .enter()
                    .append("line")
                    .attr("class", (d) => {
                        const sourceNode = graphData.getNode(d.from);
                        const targetNode = graphData.getNode(d.to);
                        return sourceNode?.pkg === targetNode?.pkg
                            ? "link"
                            : "link cross-package";
                    })
                    .attr("stroke-width", 1)
                    .attr("x1", 0)
                    .attr("y1", 0)
                    .attr("x2", 0)
                    .attr("y2", 0);

                link = linkEnter.merge(link);

                // Update nodes
                const nodeGroup = g.select(".nodes-group");
                node = nodeGroup.selectAll("circle").data(nodes, (d) => d.id);

                node.exit().remove();

                const nodeEnter = node
                    .enter()
                    .append("circle")
                    .attr("class", "node")
                    .attr("r", (d) => getNodeRadius(d))
                    .attr("fill", (d) => color(d.kind) || "#999")
                    .attr("cx", (d) => d.x || width / 2)
                    .attr("cy", (d) => d.y || height / 2)
                    .call(
                        d3
                            .drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended),
                    )
                    .on("click", (event, d) => {
                        event.stopPropagation();
                        handleNodeClick(d.id, event.shiftKey);
                    });

                node = nodeEnter.merge(node);

                // Update labels
                const labelGroup = g.select(".labels-group");
                label = labelGroup.selectAll("text").data(nodes, (d) => d.id);

                label.exit().remove();

                const labelEnter = label
                    .enter()
                    .append("text")
                    .attr("class", "node-label")
                    .text((d) => d.name)
                    .attr("x", (d) => (d.x || width / 2) + 8)
                    .attr("y", (d) => (d.y || height / 2) + 3)
                    .style("display", state.showLabels ? "block" : "none");

                label = labelEnter.merge(label);

                // Update simulation
                simulation.nodes(nodes);
                simulation.force("link").links(d3Links);
                simulation.alpha(0.3).restart();

                applyHighlighting();
            }

            function getNodeRadius(node) {
                const baseRadius = 5;
                const inDegree = (graphData.getIncomingLinks(node.id) || [])
                    .length;
                const outDegree = (graphData.getOutgoingLinks(node.id) || [])
                    .length;
                const degree = inDegree + outDegree;
                return baseRadius + Math.sqrt(degree) * 0.8;
            }

            function applyHighlighting() {
                if (state.selectedNodeIds.size === 0) {
                    node.classed(
                        "selected muted highlight out in internal",
                        false,
                    );
                    link.classed("highlight out in internal muted", false);
                    return;
                }

                // Build highlight sets for efficiency
                const highlightNodes = new Set(state.selectedNodeIds);
                const outgoingNodes = new Set();
                const incomingNodes = new Set();
                const highlightLinks = new Set();

                state.selectedNodeIds.forEach((id) => {
                    graphData.getOutgoingLinks(id).forEach((l) => {
                        outgoingNodes.add(l.to);
                        highlightLinks.add(`${l.from}-${l.to}`);
                    });
                    graphData.getIncomingLinks(id).forEach((l) => {
                        incomingNodes.add(l.from);
                        highlightLinks.add(`${l.from}-${l.to}`);
                    });
                });

                // Apply node classes
                node.classed("selected", (d) =>
                    state.selectedNodeIds.has(d.id),
                ).classed(
                    "muted",
                    (d) =>
                        !highlightNodes.has(d.id) &&
                        !outgoingNodes.has(d.id) &&
                        !incomingNodes.has(d.id),
                );

                // Apply link classes
                link.classed(
                    "highlight",
                    (d) =>
                        state.selectedNodeIds.has(d.from) ||
                        state.selectedNodeIds.has(d.to),
                )
                    .classed(
                        "out",
                        (d) =>
                            state.selectedNodeIds.has(d.from) &&
                            outgoingNodes.has(d.to),
                    )
                    .classed(
                        "in",
                        (d) =>
                            state.selectedNodeIds.has(d.to) &&
                            incomingNodes.has(d.from),
                    )
                    .classed(
                        "internal",
                        (d) =>
                            state.selectedNodeIds.has(d.from) &&
                            state.selectedNodeIds.has(d.to),
                    )
                    .classed(
                        "muted",
                        (d) =>
                            !state.selectedNodeIds.has(d.from) &&
                            !state.selectedNodeIds.has(d.to),
                    );
            }

            function handleNodeClick(nodeId, shiftKey) {
                document.getSelection().removeAllRanges();

                const newSelections = new Set();
                const targetNode = graphData.getNode(nodeId);

                // If selecting a type, also select its methods
                if (targetNode && targetNode.kind === "type") {
                    newSelections.add(nodeId);
                    const typeName = targetNode.name;

                    // Find all methods belonging to this type
                    // Methods have kind="func", type="method", and name starts with "TypeName."
                    // or id contains "(*pkg.TypeName)." or "(pkg.TypeName)."
                    graphData.nodes.forEach((n) => {
                        if (n.kind === "func" && n.type === "method") {
                            // Check if method name starts with TypeName.
                            if (n.name.startsWith(typeName + ".")) {
                                newSelections.add(n.id);
                            }
                            // Also check ID patterns like (*pkg.Graph).Method or (pkg.Graph).Method
                            else if (
                                n.id.includes(
                                    "(*" +
                                        targetNode.pkg +
                                        "." +
                                        typeName +
                                        ").",
                                ) ||
                                n.id.includes(
                                    "(" +
                                        targetNode.pkg +
                                        "." +
                                        typeName +
                                        ").",
                                )
                            ) {
                                newSelections.add(n.id);
                            }
                        }
                    });
                } else {
                    newSelections.add(nodeId);
                }

                if (shiftKey) {
                    // Toggle selection
                    newSelections.forEach((sid) => {
                        if (state.selectedNodeIds.has(sid)) {
                            state.selectedNodeIds.delete(sid);
                        } else {
                            state.selectedNodeIds.add(sid);
                        }
                    });
                } else {
                    // Replace selection
                    state.selectedNodeIds = new Set(newSelections);
                }

                applyHighlighting();
                updateSidebar();
                updateURL();
            }

            function resetFocus() {
                state.selectedNodeIds.clear();
                applyHighlighting();
                updateSidebar();
                updateURL();
            }

            function updateSidebar() {
                const info = document.getElementById("node-info");

                if (state.selectedNodeIds.size === 0) {
                    info.innerHTML = "<p>Click a node to see details</p>";
                    return;
                }

                const outgoing = [];
                const incoming = [];

                state.selectedNodeIds.forEach((id) => {
                    graphData.getOutgoingLinks(id).forEach((l) => {
                        if (!state.selectedNodeIds.has(l.to)) {
                            outgoing.push({ ...l, target: l.to });
                        }
                    });
                    graphData.getIncomingLinks(id).forEach((l) => {
                        if (!state.selectedNodeIds.has(l.from)) {
                            incoming.push({ ...l, source: l.from });
                        }
                    });
                });

                const getSortedIds = (links, key) =>
                    Array.from(new Set(links.map((l) => l[key]))).sort();

                const outIds = getSortedIds(outgoing, "target");
                const inIds = getSortedIds(incoming, "source");
                const selIds = Array.from(state.selectedNodeIds).sort();

                let html =
                    "<span class='section-header'>Selected</span><ul class='sidebar-list'>";
                selIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    html += `<li class='li-selected' onclick="handleNodeClick('${id}', event.shiftKey)">${displayName}${pkgBadge}</li>`;
                });

                html += `</ul><span class='section-header'>Outgoing (${outIds.length})</span><ul class='sidebar-list'>`;
                outIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    html += `<li class='li-outgoing' onclick="handleNodeClick('${id}', event.shiftKey)">${displayName}${pkgBadge}</li>`;
                });

                html += `</ul><span class='section-header'>Incoming (${inIds.length})</span><ul class='sidebar-list'>`;
                inIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    html += `<li class='li-incoming' onclick="handleNodeClick('${id}', event.shiftKey)">${displayName}${pkgBadge}</li>`;
                });

                info.innerHTML = html + "</ul>";
            }

            function setupEventListeners() {
                // Legend filtering
                document
                    .querySelectorAll(".legend-item[data-group]")
                    .forEach((item) => {
                        item.addEventListener("click", () => {
                            const group = item.getAttribute("data-group");
                            if (state.activeGroups.has(group)) {
                                state.activeGroups.delete(group);
                                item.classList.add("inactive");
                            } else {
                                state.activeGroups.add(group);
                                item.classList.remove("inactive");
                            }
                            updateGraph();
                            updateURL();
                        });
                    });

                // Search with debouncing
                let searchTimeout;
                document
                    .getElementById("search-box")
                    .addEventListener("input", (e) => {
                        clearTimeout(searchTimeout);
                        searchTimeout = setTimeout(() => {
                            handleSearch(e.target.value);
                        }, 150);
                    });

                // Controls
                document
                    .getElementById("show-labels")
                    .addEventListener("change", (e) => {
                        state.showLabels = e.target.checked;
                        label.style(
                            "display",
                            state.showLabels ? "block" : "none",
                        );
                        updateURL();
                    });

                document
                    .getElementById("link-distance")
                    .addEventListener("input", (e) => {
                        state.linkDistance = +e.target.value;
                        simulation.force("link").distance(state.linkDistance);
                        simulation.alpha(0.3).restart();
                        updateURL();
                    });

                document
                    .getElementById("charge")
                    .addEventListener("input", (e) => {
                        state.charge = +e.target.value;
                        simulation.force("charge").strength(state.charge);
                        simulation.alpha(0.3).restart();
                        updateURL();
                    });

                document
                    .getElementById("cluster-strength")
                    .addEventListener("input", (e) => {
                        state.clusterStrength = +e.target.value;
                        simulation.alpha(0.3).restart();
                        updateURL();
                    });

                document
                    .getElementById("fit-selection")
                    .addEventListener("click", fitSelection);

                document
                    .getElementById("reset-focus")
                    .addEventListener("click", resetFocus);

                document
                    .getElementById("export-svg")
                    .addEventListener("click", () => {
                        // Clone the SVG to avoid modifying the live one
                        const svgEl = document.getElementById("graph");
                        const w = svgEl.width;
                        const h = svgEl.height;
                        const clone = svgEl.cloneNode(true);

                        // Explicitly add the namespace and styles for standalone viewing
                        clone.setAttribute(
                            "xmlns",
                            "http://www.w3.org/2000/svg",
                        );
                        clone.setAttribute(
                            "width",
                            `${w.baseVal.value}${w.baseVal.unitType}`,
                        );
                        clone.setAttribute(
                            "height",
                            `${h.baseVal.value}${h.baseVal.unitType}`,
                        );

                        // Inline the styles so the exported file looks correct
                        const styleString = Array.from(
                            document.styleSheets[0].cssRules,
                        )
                            .map((rule) => rule.cssText)
                            .join(" ");
                        const styleEl = document.createElement("style");
                        styleEl.textContent = styleString;
                        clone.prepend(styleEl);

                        // Serialize and download
                        const svgData = new XMLSerializer().serializeToString(
                            clone,
                        );
                        const blob = new Blob([svgData], {
                            type: "image/svg+xml;charset=utf-8",
                        });
                        const url = URL.createObjectURL(blob);

                        const link = document.createElement("a");
                        link.href = url;
                        link.download = `graph-export-${new Date().getTime()}.svg`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    });

                window.onhashchange = () => {
                    loadFromURL();
                    updateGraph();
                };
            }

            function handleSearch(term) {
                const resultsDiv = document.getElementById("search-results");

                if (term.length < 1) {
                    resultsDiv.innerHTML = "";
                    return;
                }

                const normalizedTerm = term.toLowerCase();
                const matches = graphData.nodes
                    .filter((n) =>
                        n.name.toLowerCase().includes(normalizedTerm),
                    )
                    .slice(0, 50); // Limit results for performance

                let html = "<ul class='sidebar-list'>";
                matches.forEach((m) => {
                    const pkgBadge = `<span class="pkg-badge">${m.pkg.split("/").pop()}</span>`;
                    html += `<li class='li-search' onclick="handleNodeClick('${m.id}', event.shiftKey)">${m.name}${pkgBadge}</li>`;
                });
                resultsDiv.innerHTML = html + "</ul>";
            }

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            function fitSelection() {
                if (state.selectedNodeIds.size === 0) return;

                const selectedNodes = graphData.nodes.filter((n) =>
                    state.selectedNodeIds.has(n.id),
                );

                // Filter out nodes without positions
                const positionedNodes = selectedNodes.filter(
                    (n) => n.x !== undefined && n.y !== undefined,
                );
                if (positionedNodes.length === 0) return;

                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                positionedNodes.forEach((n) => {
                    if (n.x < minX) minX = n.x;
                    if (n.y < minY) minY = n.y;
                    if (n.x > maxX) maxX = n.x;
                    if (n.y > maxY) maxY = n.y;
                });

                const padding = 100;
                const selectionWidth = maxX - minX;
                const selectionHeight = maxY - minY;
                const scale = Math.min(
                    width / (selectionWidth || 1),
                    height / (selectionHeight || 1),
                    2,
                );
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                svg.transition()
                    .duration(750)
                    .call(
                        zoom.transform,
                        d3.zoomIdentity
                            .translate(
                                width / 2 - scale * centerX,
                                height / 2 - scale * centerY,
                            )
                            .scale(scale),
                    );
            }

            function updateURL() {
                const params = new URLSearchParams();
                if (state.selectedNodeIds.size > 0) {
                    params.set(
                        "sel",
                        Array.from(state.selectedNodeIds).join(","),
                    );
                }
                params.set("groups", Array.from(state.activeGroups).join(","));
                params.set("labels", state.showLabels);
                params.set("dist", state.linkDistance);
                params.set("charge", state.charge);
                params.set("cluster", state.clusterStrength);
                window.history.pushState(null, "", "#" + params.toString());
            }

            function loadFromURL() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;

                const params = new URLSearchParams(hash);

                if (params.has("sel")) {
                    state.selectedNodeIds = new Set(
                        params.get("sel").split(","),
                    );
                }

                if (params.has("groups")) {
                    state.activeGroups = new Set(
                        params.get("groups").split(","),
                    );
                    document
                        .querySelectorAll(".legend-item[data-group]")
                        .forEach((i) =>
                            i.classList.toggle(
                                "inactive",
                                !state.activeGroups.has(
                                    i.getAttribute("data-group"),
                                ),
                            ),
                        );
                }

                if (params.has("labels")) {
                    state.showLabels = params.get("labels") === "true";
                    document.getElementById("show-labels").checked =
                        state.showLabels;
                }

                if (params.has("dist")) {
                    state.linkDistance = +params.get("dist");
                    document.getElementById("link-distance").value =
                        state.linkDistance;
                    if (simulation) {
                        simulation.force("link").distance(state.linkDistance);
                    }
                }

                if (params.has("charge")) {
                    state.charge = +params.get("charge");
                    document.getElementById("charge").value = state.charge;
                    if (simulation) {
                        simulation.force("charge").strength(state.charge);
                    }
                }

                if (params.has("cluster")) {
                    state.clusterStrength = +params.get("cluster");
                    document.getElementById("cluster-strength").value =
                        state.clusterStrength;
                }
            }

            // Make handleNodeClick globally accessible
            window.handleNodeClick = handleNodeClick;

            // Initialize on load
            init();
        </script>
    </body>
</html>
