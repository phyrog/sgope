<!-- SPDX-License-Identifier: Apache-2.0 -->
<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>sgope</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style id="graph-styles">
            body {
                margin: 0;
                padding: 20px;
                font-family: Arial, sans-serif;
                background: #1a1a1a;
                color: #fff;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                height: 100vh;
                box-sizing: border-box;
            }
            #graph-container {
                border: 1px solid #444;
                background: #222;
                width: 100%;
                flex-grow: 1;
                position: relative;
                cursor: grab;
            }
            #graph-container:active {
                cursor: grabbing;
            }
            #graph {
                display: block;
                width: 100%;
                height: 100%;
            }
            .controls {
                margin-bottom: 20px;
                padding: 15px;
                background: #2a2a2a;
                border-radius: 5px;
                display: flex;
                align-items: center;
                flex-wrap: wrap;
                gap: 15px;
            }
            .webgpu-status {
                padding: 5px 10px;
                background: #333;
                border-radius: 3px;
                font-size: 12px;
                margin-left: auto;
            }
            .webgpu-status.enabled {
                background: #2d5f2d;
                color: #7fff7f;
            }
            .webgpu-status.disabled {
                background: #5f2d2d;
                color: #ff7f7f;
            }
            .legend {
                position: fixed;
                right: 20px;
                top: 160px;
                background: #2a2a2a;
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #444;
                z-index: 999;
            }
            .legend-item {
                margin: 5px 0;
                display: flex;
                align-items: center;
                font-size: 12px;
                cursor: pointer;
                transition: opacity 0.2s;
            }
            .legend-item.inactive {
                opacity: 0.3;
            }
            .legend-color {
                width: 12px;
                height: 12px;
                margin-right: 10px;
            }
            .info {
                position: fixed;
                left: 20px;
                top: 160px;
                background: #2a2a2a;
                padding: 15px;
                border-radius: 5px;
                border: 1px solid #444;
                width: 280px;
                max-height: 70vh;
                display: flex;
                flex-direction: column;
                z-index: 999;
            }
            .sidebar-scroll {
                flex-grow: 1;
                overflow-y: auto;
                padding-right: 5px;
            }
            .sidebar-list {
                list-style: none;
                padding: 0;
                margin: 10px 0;
            }
            .sidebar-list li {
                padding: 4px 8px;
                margin: 2px 0;
                background: #333;
                border-radius: 3px;
                font-size: 11px;
                cursor: pointer;
                border-left: 3px solid transparent;
            }
            .sidebar-list li:hover {
                background: #444;
            }
            .li-outgoing {
                border-left-color: #4ecdc4 !important;
            }
            .li-incoming {
                border-left-color: #ff6b6b !important;
            }
            .li-search {
                border-left-color: #fff !important;
            }
            .li-selected {
                border-left-color: #ffd700 !important;
                background: #3d3d29 !important;
            }
            button {
                background: #444;
                color: white;
                border: 1px solid #666;
                padding: 5px 10px;
                cursor: pointer;
                border-radius: 3px;
            }
            button:hover {
                background: #555;
            }
            #search-box {
                width: 100%;
                padding: 8px;
                background: #333;
                border: 1px solid #555;
                color: #fff;
                border-radius: 3px;
                margin-bottom: 10px;
                box-sizing: border-box;
            }
            #search-results {
                max-height: 240px;
                overflow-y: auto;
                border-bottom: 1px solid #444;
                margin-bottom: 10px;
                flex-shrink: 0;
            }
            #node-info {
                flex-shrink: 3;
            }
            .section-header {
                font-size: 12px;
                color: #aaa;
                text-transform: uppercase;
                margin-top: 15px;
                display: block;
                border-bottom: 1px solid #444;
            }
            .pkg-badge {
                font-size: 9px;
                background: #444;
                padding: 2px 4px;
                border-radius: 2px;
                margin-left: 4px;
                color: #aaa;
            }
            .hide-btn {
                float: right;
                font-size: 9px;
                padding: 1px 5px;
                margin-left: 5px;
                background: #555;
                border: 1px solid #666;
                color: #aaa;
                cursor: pointer;
                border-radius: 2px;
            }
            .hide-btn:hover {
                background: #666;
                color: #fff;
            }
        </style>
    </head>
    <body>
        <div class="controls">
            <h3 style="margin: 0">sgope</h3>
            <label
                ><input type="checkbox" id="show-labels" checked />
                Labels</label
            >
            <label
                >Dist:
                <input
                    type="range"
                    id="link-distance"
                    min="30"
                    max="400"
                    value="320"
            /></label>
            <label
                >Charge:
                <input
                    type="range"
                    id="charge"
                    min="-1200"
                    max="-50"
                    value="-1050"
            /></label>
            <label
                >Pkg Cluster:
                <input
                    type="range"
                    id="pkg-cluster-strength"
                    min="0"
                    max="1"
                    step="0.05"
                    value="0.3"
            /></label>
            <button id="fit-selection">Fit Selection</button>
            <button id="reset-focus">Reset Focus</button>
            <button id="export-png">Export PNG</button>
            <div class="webgpu-status" id="webgpu-status">
                Checking WebGPU...
            </div>
            <div
                style="
                    padding: 5px 10px;
                    background: #333;
                    border-radius: 3px;
                    font-size: 12px;
                    margin-left: 10px;
                "
            >
                <span id="fps-display">FPS: --</span> |
                <span id="sim-steps-display">Sim: -- steps/s</span>
            </div>
        </div>

        <div class="info">
            <input type="text" id="search-box" placeholder="Search nodes..." />
            <div id="search-results"></div>
            <div id="node-info" class="sidebar-scroll"></div>
        </div>

        <div class="legend">
            <div><strong>Node Types</strong></div>
            <div class="legend-item" data-group="test">
                <div class="legend-color"></div>
                <div>Test</div>
            </div>
            <div class="legend-item" data-group="func">
                <div class="legend-color"></div>
                <div>Function</div>
            </div>
            <div class="legend-item" data-group="type">
                <div class="legend-color"></div>
                <div>Type</div>
            </div>
            <div class="legend-item" data-group="method">
                <div class="legend-color"></div>
                <div>Method</div>
            </div>
            <div class="legend-item" data-group="field">
                <div class="legend-color"></div>
                <div>Field</div>
            </div>
            <div class="legend-item" data-group="const">
                <div class="legend-color"></div>
                <div>Const</div>
            </div>
            <div class="legend-item" data-group="var">
                <div class="legend-color"></div>
                <div>Var</div>
            </div>
        </div>

        <div id="graph-container">
            <canvas id="graph"></canvas>
        </div>

        <script type="module">
            import * as d3ForceWebgpu from "https://esm.sh/d3-force-webgpu";

            const data = DATA_PLACEHOLDER;

            // Color scheme
            const color = d3.scaleOrdinal(d3.schemeSet3);

            Array.from(document.getElementsByClassName("legend-item")).forEach(
                (n) => {
                    const colorKey = n.getAttribute("data-group");
                    Array.from(
                        n.getElementsByClassName("legend-color"),
                    ).forEach((c) => {
                        c.style = `background: ${color(colorKey)}`;
                    });
                },
            );

            // Performance optimizations: pre-compute maps and indices
            class GraphData {
                constructor(rawData) {
                    this.nodes = rawData.nodes;
                    this.links = rawData.links;

                    // Build fast lookup maps
                    this.nodeById = new Map(this.nodes.map((n) => [n.id, n]));

                    // Index links by source and target for O(1) lookups
                    this.linksBySource = new Map();
                    this.linksByTarget = new Map();

                    this.links.forEach((link) => {
                        if (!this.linksBySource.has(link.from)) {
                            this.linksBySource.set(link.from, []);
                        }
                        if (!this.linksByTarget.has(link.to)) {
                            this.linksByTarget.set(link.to, []);
                        }
                        this.linksBySource.get(link.from).push(link);
                        this.linksByTarget.get(link.to).push(link);
                    });

                    // Build package groups
                    this.packageGroups = new Map();
                    this.nodes.forEach((node) => {
                        if (!this.packageGroups.has(node.pkg)) {
                            this.packageGroups.set(node.pkg, []);
                        }
                        this.packageGroups.get(node.pkg).push(node);
                    });
                }

                getNode(id) {
                    return this.nodeById.get(id);
                }

                getOutgoingLinks(id) {
                    return this.linksBySource.get(id) || [];
                }

                getIncomingLinks(id) {
                    return this.linksByTarget.get(id) || [];
                }
            }

            // State management
            const state = {
                selectedNodeIds: new Set(),
                activeGroups: new Set([
                    "test",
                    "func",
                    "type",
                    "method",
                    "field",
                    "const",
                    "var",
                ]),
                showLabels: true,
                linkDistance: 200,
                charge: -300,
                pkgClusterStrength: 0.1,
                hiddenNodeIds: new Set(),
                webgpuEnabled: false,
                transform: { x: 0, y: 0, k: 1 },
                labelCache: new Map(),
            };

            let graphData, simulation;
            let canvas, ctx, container;
            let width, height;
            let renderScheduled = false;
            let rafId = null;
            let filteredNodes = [];
            let filteredLinks = [];
            let highlightState = {
                outgoingNodes: new Set(),
                incomingNodes: new Set(),
            };

            // Performance tracking
            let fpsFrames = [];
            let fpsLastUpdate = Date.now();
            let simSteps = 0;
            let simStepsLastUpdate = Date.now();
            let currentFPS = 0;
            let currentSimSteps = 0;

            // Debounced render for performance - only schedules one render per frame
            function scheduleRender() {
                if (!renderScheduled) {
                    renderScheduled = true;
                    rafId = requestAnimationFrame(() => {
                        render();
                        renderScheduled = false;
                    });
                }
            }

            function cancelScheduledRender() {
                if (rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                    renderScheduled = false;
                }
            }

            function updatePerformanceStats() {
                const now = Date.now();

                // Update FPS
                fpsFrames.push(now);
                fpsFrames = fpsFrames.filter((t) => now - t < 1000);

                if (now - fpsLastUpdate >= 200) {
                    currentFPS = fpsFrames.length;
                    fpsLastUpdate = now;
                    document.getElementById("fps-display").textContent =
                        `FPS: ${currentFPS}`;
                }

                // Update simulation steps/sec
                if (now - simStepsLastUpdate >= 200) {
                    currentSimSteps = Math.round(
                        (simSteps * 1000) / (now - simStepsLastUpdate),
                    );
                    simSteps = 0;
                    simStepsLastUpdate = now;
                    document.getElementById("sim-steps-display").textContent =
                        `Sim: ${currentSimSteps} steps/s`;
                }
            }

            // Check WebGPU availability
            async function checkWebGPU() {
                if (!navigator.gpu) {
                    console.warn("WebGPU not supported, falling back to CPU");
                    updateWebGPUStatus(false);
                    return false;
                }

                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    if (!adapter) {
                        console.warn(
                            "No WebGPU adapter found, falling back to CPU",
                        );
                        updateWebGPUStatus(false);
                        return false;
                    }
                    console.log(
                        "WebGPU is available and will be used for physics simulation",
                    );
                    updateWebGPUStatus(true);
                    return true;
                } catch (err) {
                    console.warn("WebGPU error:", err, "falling back to CPU");
                    updateWebGPUStatus(false);
                    return false;
                }
            }

            function updateWebGPUStatus(enabled) {
                state.webgpuEnabled = enabled;
                const statusEl = document.getElementById("webgpu-status");
                if (enabled) {
                    statusEl.textContent = "ðŸš€ WebGPU Enabled";
                    statusEl.className = "webgpu-status enabled";
                } else {
                    statusEl.textContent = "âš ï¸ CPU Fallback";
                    statusEl.className = "webgpu-status disabled";
                }
            }

            // Initialize visualization
            async function init() {
                graphData = new GraphData(data);

                // Check WebGPU support
                await checkWebGPU();

                setupCanvas();
                await setupSimulation();
                loadFromURL();
                updateGraph();
                setupEventListeners();
            }

            function setupCanvas() {
                container = document.getElementById("graph-container");
                canvas = document.getElementById("graph");
                ctx = canvas.getContext("2d");

                resizeCanvas();
                window.addEventListener("resize", resizeCanvas);
            }

            function resizeCanvas() {
                const bounds = container.getBoundingClientRect();
                width = bounds.width;
                height = bounds.height;

                // Set canvas size with device pixel ratio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                ctx.scale(dpr, dpr);

                scheduleRender();
            }

            async function setupSimulation() {
                simulation = await d3ForceWebgpu
                    .forceSimulation()
                    .force(
                        "link",
                        d3ForceWebgpu
                            .forceLink()
                            .id((d) => d.id)
                            .distance(state.linkDistance),
                    )
                    .force(
                        "charge",
                        d3ForceWebgpu.forceManyBody().strength(state.charge),
                    )
                    .force(
                        "center",
                        d3ForceWebgpu.forceCenter(width / 2, height / 2),
                    )
                    .force("x", d3ForceWebgpu.forceX(width / 2).strength(0.01))
                    .force("y", d3ForceWebgpu.forceY(height / 2).strength(0.01))
                    .stop(); // Stop automatic ticking

                // Start manual simulation loop
                startSimulationLoop();

                // Add error handler
                window.addEventListener("error", (e) => {
                    console.error(
                        "Error:",
                        e.message,
                        e.filename,
                        e.lineno,
                        e.colno,
                    );
                });
            }

            let simulationRunning = false;
            let lastSimTime = 0;

            function startSimulationLoop() {
                if (simulationRunning) return;
                simulationRunning = true;
                lastSimTime = performance.now();
                runSimulationStep();
            }

            function runSimulationStep() {
                if (!simulationRunning) return;

                const now = performance.now();
                const elapsed = now - lastSimTime;
                lastSimTime = now;

                // Run simulation tick
                if (simulation.alpha() > simulation.alphaMin()) {
                    simulation.tick();
                    simSteps++;

                    // Only trigger render occasionally to avoid overwhelming the render loop
                    // This allows simulation to run faster than rendering
                    if (simSteps % 5 === 0 || elapsed > 16) {
                        scheduleRender();
                    }
                }

                // Use setTimeout instead of requestAnimationFrame to decouple from rendering
                // This allows the simulation to run as fast as possible
                setTimeout(runSimulationStep, 0);
            }

            function stopSimulationLoop() {
                simulationRunning = false;
            }

            function render() {
                updatePerformanceStats();

                ctx.save();
                ctx.clearRect(0, 0, width, height);

                // Apply transform
                ctx.translate(state.transform.x, state.transform.y);
                ctx.scale(state.transform.k, state.transform.k);

                // Calculate opacity based on zoom
                const baseOpacity = 1;

                // Draw links - batched by style for performance
                // Group links by their rendering style to minimize state changes
                const linkBatches = new Map();

                filteredLinks.forEach((link) => {
                    // Handle both pre-simulation (from/to) and post-simulation (source/target) states
                    let sourceNode, targetNode, sourceId, targetId;

                    if (
                        typeof link.source === "object" &&
                        link.source !== null
                    ) {
                        // Post-simulation: source and target are node objects
                        sourceNode = link.source;
                        targetNode = link.target;
                        sourceId = sourceNode.id;
                        targetId = targetNode.id;
                    } else {
                        // Pre-simulation or string IDs: look up nodes by ID
                        sourceId = link.source || link.from;
                        targetId = link.target || link.to;
                        sourceNode = graphData.getNode(sourceId);
                        targetNode = graphData.getNode(targetId);
                    }

                    if (
                        !sourceNode ||
                        !targetNode ||
                        sourceNode.x === undefined ||
                        targetNode.x === undefined
                    ) {
                        return; // Skip if nodes don't have positions yet
                    }

                    let opacity = 0.6 * baseOpacity;
                    let strokeWidth = 1;
                    let strokeStyle = "#fff";
                    let isDashed = sourceNode?.pkg !== targetNode?.pkg;

                    // Apply highlighting
                    if (state.selectedNodeIds.size > 0) {
                        const isHighlighted =
                            state.selectedNodeIds.has(sourceId) ||
                            state.selectedNodeIds.has(targetId);

                        if (isHighlighted) {
                            opacity = baseOpacity;
                            strokeWidth = 2;

                            if (
                                state.selectedNodeIds.has(sourceId) &&
                                state.selectedNodeIds.has(targetId)
                            ) {
                                strokeStyle = "#ffffff";
                            } else if (
                                state.selectedNodeIds.has(sourceId) &&
                                highlightState.outgoingNodes.has(targetId)
                            ) {
                                strokeStyle = "#4ecdc4";
                            } else if (
                                state.selectedNodeIds.has(targetId) &&
                                highlightState.incomingNodes.has(sourceId)
                            ) {
                                strokeStyle = "#ff6b6b";
                            }
                        } else {
                            opacity = 0.3 * baseOpacity;
                        }
                    }

                    // Create a batch key for this style combination
                    const batchKey = `${opacity.toFixed(2)}_${strokeWidth}_${strokeStyle}_${isDashed ? "dash" : "solid"}`;

                    if (!linkBatches.has(batchKey)) {
                        linkBatches.set(batchKey, {
                            opacity,
                            strokeWidth,
                            strokeStyle,
                            isDashed,
                            links: [],
                        });
                    }

                    linkBatches.get(batchKey).links.push({
                        x1: sourceNode.x,
                        y1: sourceNode.y,
                        x2: targetNode.x,
                        y2: targetNode.y,
                    });
                });

                // Draw each batch with a single beginPath for all links in that style
                linkBatches.forEach((batch) => {
                    ctx.globalAlpha = batch.opacity;
                    ctx.strokeStyle = batch.strokeStyle;
                    ctx.lineWidth = batch.strokeWidth;
                    ctx.setLineDash(batch.isDashed ? [4, 4] : []);

                    ctx.beginPath();
                    batch.links.forEach((link) => {
                        ctx.moveTo(link.x1, link.y1);
                        ctx.lineTo(link.x2, link.y2);
                    });
                    ctx.stroke();
                });

                ctx.setLineDash([]);

                // Draw nodes
                if (state.transform.k > 0.1) {
                    filteredNodes.forEach((node) => {
                        const size = getNodeRadius(node) * 2; // Use radius to determine side length
                        const offset = size / 2;

                        let fillColor = color(node.kind);
                        if (node.kind === "func" && node.type === "method") {
                            fillColor = color("method");
                        } else if (
                            node.kind === "var" &&
                            node.type === "field"
                        ) {
                            fillColor = color("field");
                        }

                        let strokeColor = "rgba(255, 255, 255, 0.47)";
                        let strokeWidth = 1.5;
                        let nodeOpacity = baseOpacity;

                        // Apply highlighting
                        if (state.selectedNodeIds.size > 0) {
                            if (state.selectedNodeIds.has(node.id)) {
                                strokeColor = "#fff";
                                strokeWidth = 2;
                            } else if (
                                !highlightState.outgoingNodes.has(node.id) &&
                                !highlightState.incomingNodes.has(node.id)
                            ) {
                                nodeOpacity = baseOpacity * 0.5;
                            }
                        }

                        ctx.globalAlpha = nodeOpacity;
                        ctx.fillStyle = fillColor;
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = strokeWidth;

                        // Change: Draw Rect instead of Arc
                        ctx.fillRect(
                            node.x - offset,
                            node.y - offset,
                            size,
                            size,
                        );
                        ctx.strokeRect(
                            node.x - offset,
                            node.y - offset,
                            size,
                            size,
                        );

                        // Draw selection glow
                        if (
                            state.selectedNodeIds.size > 0 &&
                            state.selectedNodeIds.has(node.id)
                        ) {
                            ctx.globalAlpha = 0.3;
                            ctx.strokeStyle = "#fff";
                            ctx.lineWidth = 4;
                            // Glow follows the rectangle shape
                            ctx.strokeRect(
                                node.x - offset - 2,
                                node.y - offset - 2,
                                size + 4,
                                size + 4,
                            );
                        }
                    });
                }

                if (state.showLabels && state.transform.k > 0.6) {
                    // 1. Calculate viewport bounds for culling
                    const viewLeft = -state.transform.x / state.transform.k;
                    const viewTop = -state.transform.y / state.transform.k;
                    const viewRight = viewLeft + width / state.transform.k;
                    const viewBottom = viewTop + height / state.transform.k;

                    filteredNodes.forEach((node) => {
                        // View Culling: Skip if off-screen (buffer of 100 units)
                        if (
                            node.x < viewLeft - 100 ||
                            node.x > viewRight ||
                            node.y < viewTop - 20 ||
                            node.y > viewBottom
                        )
                            return;

                        // 2. Get or Create Cached Label
                        let cached = state.labelCache.get(node.id);
                        if (!cached) {
                            const labelCanvas =
                                document.createElement("canvas");
                            const lCtx = labelCanvas.getContext("2d");
                            const baseFontSize = 20;
                            lCtx.font = `${baseFontSize}px Arial`;
                            const metrics = lCtx.measureText(node.name);

                            const padding = 4;
                            labelCanvas.width = metrics.width + padding * 2;
                            labelCanvas.height = baseFontSize * 1.2;

                            // Draw background rectangle
                            lCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
                            lCtx.fillRect(
                                0,
                                0,
                                labelCanvas.width,
                                labelCanvas.height,
                            );

                            // Draw text
                            lCtx.font = `${baseFontSize}px Arial`;
                            lCtx.textBaseline = "middle";
                            lCtx.fillStyle = "#ffffff";
                            lCtx.fillText(
                                node.name,
                                padding,
                                labelCanvas.height / 2,
                            );

                            cached = {
                                canvas: labelCanvas,
                                width: labelCanvas.width,
                                height: labelCanvas.height,
                            };
                            state.labelCache.set(node.id, cached);
                        }

                        // 3. Scale label based on node size and position outside node boundary
                        const nodeRadius = getNodeRadius(node);
                        // Scale label proportionally to node size (larger nodes get larger labels)
                        const labelScale = Math.max(
                            0.5,
                            Math.min(1.5, nodeRadius / 8),
                        );
                        const worldHeight = 10 * labelScale;
                        const worldWidth =
                            (cached.width / cached.height) * worldHeight;

                        let textOpacity = baseOpacity;
                        if (state.selectedNodeIds.size > 0) {
                            if (
                                !state.selectedNodeIds.has(node.id) &&
                                !highlightState.outgoingNodes.has(node.id) &&
                                !highlightState.incomingNodes.has(node.id)
                            ) {
                                textOpacity = baseOpacity * 0.3;
                            }
                        }

                        ctx.globalAlpha = textOpacity;

                        // Position label outside the node boundary
                        // For square nodes, position it at the right edge + small gap
                        const nodeSize = nodeRadius * 2;
                        const labelX = node.x + nodeSize / 2 + 2;

                        // Stamping the cache onto the main canvas
                        ctx.drawImage(
                            cached.canvas,
                            labelX,
                            node.y - worldHeight / 2, // Center vertically relative to node
                            worldWidth,
                            worldHeight,
                        );
                    });
                }

                ctx.restore();
            }

            function updateGraph() {
                // Filter nodes and links based on active groups
                filteredNodes = graphData.nodes.filter((n) => {
                    let show = true;

                    if (n.test) {
                        show &&= state.activeGroups.has("test");
                    }

                    if (n.kind === "func" && n.type === "method") {
                        show &&= state.activeGroups.has("method");
                    } else if (n.kind === "var" && n.type === "field") {
                        show &&= state.activeGroups.has("field");
                    } else {
                        show &&= state.activeGroups.has(n.kind);
                    }

                    show &&= !state.hiddenNodeIds.has(n.id);

                    return show;
                });
                const filteredNodeIds = new Set(filteredNodes.map((n) => n.id));

                console.log("Node count:", filteredNodes.length);

                // Helper function to find visible parent node or return null
                const findVisibleNode = (nodeId) => {
                    let current = nodeId;
                    const visited = new Set();

                    while (current && !filteredNodeIds.has(current)) {
                        if (visited.has(current)) {
                            return null;
                        }
                        visited.add(current);

                        const node = graphData.nodeById.get(current);
                        if (
                            node &&
                            node.parent &&
                            graphData.nodeById.has(node.parent)
                        ) {
                            current = node.parent;
                        } else {
                            return null;
                        }
                    }

                    return filteredNodeIds.has(current) ? current : null;
                };

                // Redirect links through parent nodes when endpoints are hidden
                filteredLinks = [];
                const linkKeys = new Set();

                graphData.links.forEach((l) => {
                    let from = l.from;
                    let to = l.to;

                    if (!filteredNodeIds.has(from)) {
                        from = findVisibleNode(from);
                    }
                    if (!filteredNodeIds.has(to)) {
                        to = findVisibleNode(to);
                    }

                    if (from && to) {
                        const linkKey = `${from}-${to}`;
                        if (!linkKeys.has(linkKey)) {
                            linkKeys.add(linkKey);
                            filteredLinks.push({ ...l, from, to });
                        }
                    }
                });

                console.log("Link count:", filteredLinks.length);

                state.labelCache.clear();
                updateSimulation();
                updateSidebar();
            }

            function updateSimulation() {
                // Initialize node positions if not set
                filteredNodes.forEach((node) => {
                    if (node.x === undefined) {
                        node.x = width / 2 + (Math.random() - 0.5) * 100;
                    }
                    if (node.y === undefined) {
                        node.y = height / 2 + (Math.random() - 0.5) * 100;
                    }
                });

                // Convert links to D3 format
                const d3Links = filteredLinks.map((l) => ({
                    source: l.from,
                    target: l.to,
                    from: l.from,
                    to: l.to,
                }));

                simulation.nodes(filteredNodes);

                // Apply package-aware link strength
                simulation
                    .force("link")
                    .links(d3Links)
                    .strength((link) => {
                        if (state.pkgClusterStrength === 0) {
                            return 1.0; // Normal strength when clustering disabled
                        }

                        // Get source and target nodes
                        const sourceNode =
                            typeof link.source === "object"
                                ? link.source
                                : graphData.getNode(link.source);
                        const targetNode =
                            typeof link.target === "object"
                                ? link.target
                                : graphData.getNode(link.target);

                        if (!sourceNode || !targetNode) return 1.0;

                        // If cross-package link, weaken it based on clustering strength
                        if (
                            sourceNode.pkg &&
                            targetNode.pkg &&
                            sourceNode.pkg !== targetNode.pkg
                        ) {
                            // At max clustering (1.0), cross-package links have near-zero strength
                            return Math.max(
                                0.3,
                                1.0 - state.pkgClusterStrength,
                            );
                        }

                        // Same package: full strength
                        return 1.0;
                    });

                // Apply package-based repulsion by modifying charge force
                if (state.pkgClusterStrength > 0) {
                    // Create a map for quick package lookup
                    const nodePkgMap = new Map();
                    filteredNodes.forEach((n) => {
                        nodePkgMap.set(n.id, n.pkg);
                    });

                    // Set charge strength based on whether nodes are in same package
                    simulation.force("charge").strength((source, target) => {
                        const sourcePkg = nodePkgMap.get(source.id);
                        const targetPkg = nodePkgMap.get(target.id);

                        // If different packages, apply extra repulsion
                        if (sourcePkg && targetPkg && sourcePkg !== targetPkg) {
                            return (
                                state.charge *
                                (1 + state.pkgClusterStrength * 2)
                            );
                        }
                        // Same package: normal charge
                        return state.charge;
                    });
                } else {
                    // No clustering: uniform charge and link strength
                    simulation.force("charge").strength(state.charge);
                }

                simulation.alpha(0.3);

                applyHighlighting();
            }

            function getNodeRadius(node) {
                const baseRadius = 5;
                const inDegree = (graphData.getIncomingLinks(node.id) || [])
                    .length;
                const outDegree = (graphData.getOutgoingLinks(node.id) || [])
                    .length;
                const degree = inDegree + outDegree;
                return baseRadius + Math.sqrt(degree) * 0.8;
            }

            function toggleNodeVisibility(nodeId) {
                if (state.hiddenNodeIds.has(nodeId)) {
                    state.hiddenNodeIds.delete(nodeId);
                } else {
                    state.hiddenNodeIds.add(nodeId);
                }
                updateGraph();
            }

            function applyHighlighting() {
                highlightState.outgoingNodes.clear();
                highlightState.incomingNodes.clear();

                if (state.selectedNodeIds.size === 0) {
                    scheduleRender();
                    return;
                }

                state.selectedNodeIds.forEach((id) => {
                    graphData.getOutgoingLinks(id).forEach((l) => {
                        highlightState.outgoingNodes.add(l.to);
                    });
                    graphData.getIncomingLinks(id).forEach((l) => {
                        highlightState.incomingNodes.add(l.from);
                    });
                });

                scheduleRender();
            }

            function handleNodeClick(nodeId, shiftKey) {
                document.getSelection().removeAllRanges();

                const newSelections = new Set();
                const targetNode = graphData.getNode(nodeId);

                if (targetNode && targetNode.kind === "type") {
                    newSelections.add(nodeId);
                    const typeName = targetNode.name;

                    graphData.nodes.forEach((n) => {
                        if (
                            (n.kind === "func" && n.type === "method") ||
                            (n.kind === "var" && n.type === "field")
                        ) {
                            if (n.name.startsWith(typeName + ".")) {
                                newSelections.add(n.id);
                            } else if (
                                n.id.includes(
                                    "(*" +
                                        targetNode.pkg +
                                        "." +
                                        typeName +
                                        ").",
                                ) ||
                                n.id.includes(
                                    "(" +
                                        targetNode.pkg +
                                        "." +
                                        typeName +
                                        ").",
                                )
                            ) {
                                newSelections.add(n.id);
                            }
                        }
                    });
                } else {
                    newSelections.add(nodeId);
                }

                if (shiftKey) {
                    newSelections.forEach((sid) => {
                        if (state.selectedNodeIds.has(sid)) {
                            state.selectedNodeIds.delete(sid);
                        } else {
                            state.selectedNodeIds.add(sid);
                        }
                    });
                } else {
                    state.selectedNodeIds = new Set(newSelections);
                }

                applyHighlighting();
                updateSidebar();
                updateURL();
            }

            function resetFocus() {
                state.selectedNodeIds.clear();
                applyHighlighting();
                updateSidebar();
                updateURL();
            }

            function updateSidebar() {
                const info = document.getElementById("node-info");

                if (state.selectedNodeIds.size === 0) {
                    info.innerHTML = "<p>Click a node to see details</p>";
                    return;
                }

                const outgoing = [];
                const incoming = [];

                state.selectedNodeIds.forEach((id) => {
                    graphData.getOutgoingLinks(id).forEach((l) => {
                        if (!state.selectedNodeIds.has(l.to)) {
                            outgoing.push({ ...l, target: l.to });
                        }
                    });
                    graphData.getIncomingLinks(id).forEach((l) => {
                        if (!state.selectedNodeIds.has(l.from)) {
                            incoming.push({ ...l, source: l.from });
                        }
                    });
                });

                const getSortedIds = (links, key) =>
                    Array.from(new Set(links.map((l) => l[key]))).sort();

                const outIds = getSortedIds(outgoing, "target");
                const inIds = getSortedIds(incoming, "source");
                const selIds = Array.from(state.selectedNodeIds).sort();

                let html =
                    "<span class='section-header'>Selected</span><ul class='sidebar-list'>";
                selIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    const isHidden = state.hiddenNodeIds.has(id);
                    const btnText = isHidden ? "show" : "hide";
                    html += `<li class='li-selected' onclick="handleNodeClick('${id}', event.shiftKey)"><button class='hide-btn' onclick="event.stopPropagation(); toggleNodeVisibility('${id}')">${btnText}</button>${displayName}${pkgBadge}</li>`;
                });

                html += `</ul><span class='section-header'>Outgoing (${outIds.length})</span><ul class='sidebar-list'>`;
                outIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    const isHidden = state.hiddenNodeIds.has(id);
                    const btnText = isHidden ? "show" : "hide";
                    html += `<li class='li-outgoing' onclick="handleNodeClick('${id}', event.shiftKey)"><button class='hide-btn' onclick="event.stopPropagation(); toggleNodeVisibility('${id}')">${btnText}</button>${displayName}${pkgBadge}</li>`;
                });

                html += `</ul><span class='section-header'>Incoming (${inIds.length})</span><ul class='sidebar-list'>`;
                inIds.forEach((id) => {
                    const node = graphData.getNode(id);
                    const displayName = node ? node.name : id;
                    const pkgBadge = node
                        ? `<span class="pkg-badge">${node.pkg.split("/").pop()}</span>`
                        : "";
                    const isHidden = state.hiddenNodeIds.has(id);
                    const btnText = isHidden ? "show" : "hide";
                    html += `<li class='li-incoming' onclick="handleNodeClick('${id}', event.shiftKey)"><button class='hide-btn' onclick="event.stopPropagation(); toggleNodeVisibility('${id}')">${btnText}</button>${displayName}${pkgBadge}</li>`;
                });

                info.innerHTML = html + "</ul>";
            }

            // Canvas interaction handlers
            function getMousePos(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top,
                };
            }

            function screenToWorld(screenX, screenY) {
                return {
                    x: (screenX - state.transform.x) / state.transform.k,
                    y: (screenY - state.transform.y) / state.transform.k,
                };
            }

            function findNodeAtPosition(worldX, worldY) {
                for (let i = filteredNodes.length - 1; i >= 0; i--) {
                    const node = filteredNodes[i];
                    const radius = getNodeRadius(node);
                    const dx = worldX - node.x;
                    const dy = worldY - node.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= radius * radius) {
                        return node;
                    }
                }
                return null;
            }

            let draggedNode = null;
            let isPanning = false;
            let lastMousePos = null;
            let hasMoved = false;
            let hoveredNode = null;

            function setupEventListeners() {
                // Canvas interaction events
                canvas.addEventListener("mousedown", (event) => {
                    const mousePos = getMousePos(event);
                    const worldPos = screenToWorld(mousePos.x, mousePos.y);
                    const node = findNodeAtPosition(worldPos.x, worldPos.y);

                    hasMoved = false;

                    if (node) {
                        draggedNode = node;
                        draggedNode.fx = draggedNode.x;
                        draggedNode.fy = draggedNode.y;
                        simulation.alphaTarget(0.3);
                    } else {
                        isPanning = true;
                        lastMousePos = mousePos;
                    }
                });

                canvas.addEventListener("mousemove", (event) => {
                    if (draggedNode) {
                        hasMoved = true;
                        const mousePos = getMousePos(event);
                        const worldPos = screenToWorld(mousePos.x, mousePos.y);
                        draggedNode.fx = worldPos.x;
                        draggedNode.fy = worldPos.y;
                        updateSimulation();
                    } else if (isPanning && lastMousePos) {
                        const mousePos = getMousePos(event);
                        const dx = mousePos.x - lastMousePos.x;
                        const dy = mousePos.y - lastMousePos.y;

                        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                            hasMoved = true;
                        }

                        state.transform.x += dx;
                        state.transform.y += dy;
                        lastMousePos = mousePos;
                        scheduleRender();
                        updateURL();
                    } else {
                        // Update cursor based on hover state
                        const mousePos = getMousePos(event);
                        const worldPos = screenToWorld(mousePos.x, mousePos.y);
                        const node = findNodeAtPosition(worldPos.x, worldPos.y);

                        if (node !== hoveredNode) {
                            hoveredNode = node;
                            container.style.cursor = node ? "pointer" : "grab";
                        }
                    }
                });

                canvas.addEventListener("mouseup", (event) => {
                    if (draggedNode) {
                        simulation.alphaTarget(0);
                        draggedNode.fx = null;
                        draggedNode.fy = null;
                        draggedNode = null;
                    } else if (isPanning) {
                        isPanning = false;
                        lastMousePos = null;
                    }
                });

                canvas.addEventListener("click", (event) => {
                    // Don't process clicks if we were dragging or panning
                    if (hasMoved) {
                        hasMoved = false;
                        return;
                    }

                    const mousePos = getMousePos(event);
                    const worldPos = screenToWorld(mousePos.x, mousePos.y);
                    const node = findNodeAtPosition(worldPos.x, worldPos.y);

                    if (node) {
                        handleNodeClick(node.id, event.shiftKey);
                    } else {
                        resetFocus();
                    }
                });

                canvas.addEventListener("wheel", (event) => {
                    event.preventDefault();

                    const mousePos = getMousePos(event);
                    const worldPosBefore = screenToWorld(
                        mousePos.x,
                        mousePos.y,
                    );

                    // Reduced zoom speed for smoother control
                    const scaleFactor = event.deltaY > 0 ? 0.98 : 1.02;
                    const newScale = Math.max(
                        0.01,
                        Math.min(4, state.transform.k * scaleFactor),
                    );
                    state.transform.k = newScale;

                    const worldPosAfter = screenToWorld(mousePos.x, mousePos.y);
                    state.transform.x +=
                        (worldPosAfter.x - worldPosBefore.x) *
                        state.transform.k;
                    state.transform.y +=
                        (worldPosAfter.y - worldPosBefore.y) *
                        state.transform.k;

                    scheduleRender();
                    updateURL();
                });

                // UI control events
                document
                    .querySelectorAll(".legend-item[data-group]")
                    .forEach((item) => {
                        item.addEventListener("click", () => {
                            const group = item.getAttribute("data-group");
                            if (state.activeGroups.has(group)) {
                                state.activeGroups.delete(group);
                                item.classList.add("inactive");
                            } else {
                                state.activeGroups.add(group);
                                item.classList.remove("inactive");
                            }
                            updateGraph();
                            updateURL();
                        });
                    });

                let searchTimeout;
                document
                    .getElementById("search-box")
                    .addEventListener("input", (e) => {
                        clearTimeout(searchTimeout);
                        searchTimeout = setTimeout(() => {
                            handleSearch(e.target.value);
                        }, 150);
                    });

                document
                    .getElementById("show-labels")
                    .addEventListener("change", (e) => {
                        state.showLabels = e.target.checked;
                        scheduleRender();
                        updateURL();
                    });

                document
                    .getElementById("link-distance")
                    .addEventListener("input", (e) => {
                        state.linkDistance = +e.target.value;
                        updateSimulation(); // Rebuild to update clustering link distances
                        updateURL();
                    });

                document
                    .getElementById("charge")
                    .addEventListener("input", (e) => {
                        state.charge = +e.target.value;
                        simulation.force("charge").strength(state.charge);
                        simulation.alpha(0.3);
                        updateURL();
                    });

                document
                    .getElementById("pkg-cluster-strength")
                    .addEventListener("input", (e) => {
                        state.pkgClusterStrength = +e.target.value;
                        updateSimulation(); // Rebuild links with new clustering
                        updateURL();
                    });

                document
                    .getElementById("fit-selection")
                    .addEventListener("click", fitSelection);

                document
                    .getElementById("reset-focus")
                    .addEventListener("click", resetFocus);

                document
                    .getElementById("export-png")
                    .addEventListener("click", () => {
                        canvas.toBlob((blob) => {
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement("a");
                            link.href = url;
                            link.download = `graph-export-${new Date().getTime()}.png`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        });
                    });

                window.onhashchange = () => {
                    loadFromURL();
                    updateGraph();
                };
            }

            function handleSearch(term) {
                const resultsDiv = document.getElementById("search-results");

                if (term.length < 1) {
                    resultsDiv.innerHTML = "";
                    return;
                }

                const normalizedTerm = term.toLowerCase();
                const matches = graphData.nodes
                    .filter((n) =>
                        n.name.toLowerCase().includes(normalizedTerm),
                    )
                    .slice(0, 50);

                let html = "<ul class='sidebar-list'>";
                matches.forEach((m) => {
                    const pkgBadge = `<span class="pkg-badge">${m.pkg.split("/").pop()}</span>`;
                    const isHidden = state.hiddenNodeIds.has(m.id);
                    const btnText = isHidden ? "show" : "hide";
                    html += `<li class='li-search' onclick="handleNodeClick('${m.id}', event.shiftKey)"><button class='hide-btn' onclick="event.stopPropagation(); toggleNodeVisibility('${m.id}')">${btnText}</button>${m.name}${pkgBadge}</li>`;
                });
                resultsDiv.innerHTML = html + "</ul>";
            }

            function fitSelection() {
                if (state.selectedNodeIds.size === 0) return;

                const selectedNodes = filteredNodes.filter((n) =>
                    state.selectedNodeIds.has(n.id),
                );

                const positionedNodes = selectedNodes.filter(
                    (n) => n.x !== undefined && n.y !== undefined,
                );
                if (positionedNodes.length === 0) return;

                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                positionedNodes.forEach((n) => {
                    if (n.x < minX) minX = n.x;
                    if (n.y < minY) minY = n.y;
                    if (n.x > maxX) maxX = n.x;
                    if (n.y > maxY) maxY = n.y;
                });

                const padding = 100;
                const selectionWidth = maxX - minX + padding * 2;
                const selectionHeight = maxY - minY + padding * 2;
                const scale = Math.min(
                    width / selectionWidth,
                    height / selectionHeight,
                    2,
                );
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                // Animate transform
                const startTransform = { ...state.transform };
                const endTransform = {
                    x: width / 2 - scale * centerX,
                    y: height / 2 - scale * centerY,
                    k: scale,
                };

                const duration = 750;
                const startTime = Date.now();

                function animate() {
                    const elapsed = Date.now() - startTime;
                    const t = Math.min(1, elapsed / duration);
                    const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOutQuad

                    state.transform.x =
                        startTransform.x +
                        (endTransform.x - startTransform.x) * eased;
                    state.transform.y =
                        startTransform.y +
                        (endTransform.y - startTransform.y) * eased;
                    state.transform.k =
                        startTransform.k +
                        (endTransform.k - startTransform.k) * eased;

                    render();

                    if (t < 1) {
                        requestAnimationFrame(animate);
                    }
                }

                animate();
            }

            function updateURL() {
                const params = new URLSearchParams();
                if (state.selectedNodeIds.size > 0) {
                    params.set(
                        "sel",
                        Array.from(state.selectedNodeIds).join(","),
                    );
                }
                params.set("groups", Array.from(state.activeGroups).join(","));
                params.set("labels", state.showLabels);
                params.set("dist", state.linkDistance);
                params.set("charge", state.charge);
                params.set("pkgCluster", state.pkgClusterStrength);
                params.set("zoom", state.transform.k.toFixed(3));
                params.set("x", state.transform.x.toFixed(2));
                params.set("y", state.transform.y.toFixed(2));
                window.history.pushState(null, "", "#" + params.toString());
            }

            function loadFromURL() {
                const hash = window.location.hash.substring(1);
                if (!hash) return;

                const params = new URLSearchParams(hash);

                if (params.has("sel")) {
                    state.selectedNodeIds = new Set(
                        params.get("sel").split(","),
                    );
                }

                if (params.has("groups")) {
                    state.activeGroups = new Set(
                        params.get("groups").split(","),
                    );
                    document
                        .querySelectorAll(".legend-item[data-group]")
                        .forEach((i) =>
                            i.classList.toggle(
                                "inactive",
                                !state.activeGroups.has(
                                    i.getAttribute("data-group"),
                                ),
                            ),
                        );
                }

                if (params.has("labels")) {
                    state.showLabels = params.get("labels") === "true";
                    document.getElementById("show-labels").checked =
                        state.showLabels;
                }

                if (params.has("dist")) {
                    state.linkDistance = +params.get("dist");
                    document.getElementById("link-distance").value =
                        state.linkDistance;
                    if (simulation) {
                        simulation.force("link").distance(state.linkDistance);
                    }
                }

                if (params.has("charge")) {
                    state.charge = +params.get("charge");
                    document.getElementById("charge").value = state.charge;
                    if (simulation) {
                        simulation.force("charge").strength(state.charge);
                    }
                }

                if (params.has("pkgCluster")) {
                    state.pkgClusterStrength = +params.get("pkgCluster");
                    document.getElementById("pkg-cluster-strength").value =
                        state.pkgClusterStrength;
                }

                if (params.has("zoom")) {
                    state.transform.k = +params.get("zoom");
                }

                if (params.has("x")) {
                    state.transform.x = +params.get("x");
                }

                if (params.has("y")) {
                    state.transform.y = +params.get("y");
                }
            }

            window.handleNodeClick = handleNodeClick;
            window.toggleNodeVisibility = toggleNodeVisibility;

            init();
        </script>
    </body>
</html>
